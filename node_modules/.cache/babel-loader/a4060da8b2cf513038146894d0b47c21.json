{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactSpring = require('react-spring');\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction TouchMoveRecord(e) {\n  var _getTouchPosition = (0, _utils.getTouchPosition)(e),\n      x = _getTouchPosition.x,\n      y = _getTouchPosition.y;\n\n  this.x = x;\n  this.y = y;\n  this.time = Date.now();\n}\n\nvar defaultProps = {\n  component: 'div',\n  cardSize: global.innerWidth || 320,\n  cardCount: 1,\n  cardPadCount: 2,\n  defaultCursor: 0,\n  loop: true,\n  autoplay: 0,\n  vertical: false,\n  renderCard: function renderCard() {},\n  precision: 0.001,\n  tension: 200,\n  friction: 25,\n  moveScale: 1,\n  onRest: function onRest() {},\n  onDragStart: function onDragStart() {},\n  onDragEnd: function onDragEnd() {},\n  onDragCancel: function onDragCancel() {},\n  maxOverflow: 0.5,\n  clickTolerance: 2,\n  ignoreCrossMove: true\n};\nvar propsKeys = Object.keys(defaultProps);\n\nvar TouchCarousel = function (_React$PureComponent) {\n  _inherits(TouchCarousel, _React$PureComponent);\n\n  function TouchCarousel(props) {\n    _classCallCheck(this, TouchCarousel);\n\n    var _this = _possibleConstructorReturn(this, (TouchCarousel.__proto__ || Object.getPrototypeOf(TouchCarousel)).call(this, props));\n\n    _this.onTouchStart = function (e) {\n      var oldTouchCount = _this.touchCount;\n      _this.touchCount += e.changedTouches.length;\n\n      _this.setState({\n        active: true\n      });\n\n      _this.stopAutoplay();\n\n      _this.tracingTouchId = (0, _utils.getTouchId)(e);\n      _this.touchMoves = [new TouchMoveRecord(e)];\n      _this.isMovingCross = null;\n      var _this$props = _this.props,\n          cardSize = _this$props.cardSize,\n          clickTolerance = _this$props.clickTolerance; // User click a card before it's in place but near, allow the clicking.\n      // Otherwise it's only a grab.\n\n      _this.grabbing = cardSize * Math.abs(_this.usedCursor - _this.state.cursor) > clickTolerance; // When user clicks or grabs the scroll, cancel the spring effect.\n\n      if (!oldTouchCount) {\n        _this.setCursor(_this.usedCursor).then(_this.modCursor);\n      } else {\n        _this.modCursor();\n      }\n    };\n\n    _this.onTouchMove = function (e) {\n      _this.grabbing = false;\n      var touchMove = new TouchMoveRecord(e);\n      var touchId = (0, _utils.getTouchId)(e);\n\n      if (touchId !== _this.tracingTouchId || !_this.touchMoves.length) {\n        _this.touchMoves = [touchMove];\n      }\n\n      _this.tracingTouchId = touchId;\n      var shouldIgnore = e.defaultPrevented;\n\n      if (!shouldIgnore && _this.state.active) {\n        if (_this.isMovingCross == null) {\n          var _this$props2 = _this.props,\n              _vertical = _this$props2.vertical,\n              ignoreCrossMove = _this$props2.ignoreCrossMove;\n          var factor = ignoreCrossMove;\n\n          if (typeof factor !== 'number') {\n            factor = factor ? 1 : 0;\n          }\n\n          var mainAxis = _vertical ? 'y' : 'x';\n          var crossAxis = _vertical ? 'x' : 'y';\n          var deltMain = Math.abs(touchMove[mainAxis] - _this.touchMoves[0][mainAxis]);\n          var deltCross = Math.abs(touchMove[crossAxis] - _this.touchMoves[0][crossAxis]);\n          _this.isMovingCross = deltCross * factor > deltMain;\n        }\n\n        shouldIgnore = _this.isMovingCross;\n      }\n\n      if (shouldIgnore) {\n        return;\n      } // Prevent the default action i.e. page scroll.\n      // NOTE: in Chrome 56+ touchmove event listeners are passive by default,\n      // please use CSS `touch-action` for it.\n\n\n      e.preventDefault();\n      var _this$props3 = _this.props,\n          cardSize = _this$props3.cardSize,\n          moveScale = _this$props3.moveScale,\n          vertical = _this$props3.vertical,\n          onDragStart = _this$props3.onDragStart;\n      var lastMove = _this.touchMoves[_this.touchMoves.length - 1];\n      var xy = vertical ? 'y' : 'x';\n      var distance = touchMove[xy] - lastMove[xy];\n\n      _this.setState({\n        dragging: true\n      }, _this.state.dragging ? undefined : onDragStart);\n\n      _this.setCursor(_this.state.cursor + distance / cardSize * moveScale);\n\n      _this.touchMoves.push(touchMove);\n\n      if (_this.touchMoves.length > 250) {\n        _this.touchMoves.splice(0, 50);\n      }\n    };\n\n    _this.onTouchEndOrCancel = function (e) {\n      var type = e.type;\n      _this.touchCount -= e.changedTouches.length;\n\n      if (_this.touchCount > 0) {\n        _this.touchMoves = [];\n        return;\n      } // prevent click event for grab actions\n\n\n      if (_this.grabbing) {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n\n      var wasDragging = _this.state.dragging;\n      var targetCursor = null; // Due to multi-touch, records can be empty even if .dragging is true.\n      // So check both.\n\n      if (wasDragging && _this.touchMoves.length) {\n        var _this$props4 = _this.props,\n            cardSize = _this$props4.cardSize,\n            moveScale = _this$props4.moveScale,\n            vertical = _this$props4.vertical;\n        var friction = _this.props.friction / 1e6;\n        var touchMoves = _this.touchMoves;\n        var i = touchMoves.length;\n        var duration = 0;\n\n        while (--i >= 0 && duration < 100) {\n          duration = Date.now() - touchMoves[i].time;\n        }\n\n        i++;\n        var xy = vertical ? 'y' : 'x';\n        var touchMoveVelocity = ((0, _utils.getTouchPosition)(e)[xy] - touchMoves[i][xy]) / duration;\n        var momentumDistance = touchMoveVelocity * Math.abs(touchMoveVelocity) / friction / 2;\n        var cursor = _this.state.cursor;\n        var cursorDelta = (0, _utils.clamp)(momentumDistance / cardSize * moveScale, Math.floor(cursor) - cursor, Math.ceil(cursor) - cursor);\n        targetCursor = Math.round(cursor + cursorDelta);\n        _this.touchMoves = [];\n      } else {\n        // User grabs and then releases without any move in between.\n        // Snap the cursor.\n        targetCursor = Math.round(_this.state.cursor);\n      }\n\n      _this.setState({\n        active: false,\n        dragging: false\n      }, function () {\n        _this.setCursor(targetCursor);\n\n        if (wasDragging) {\n          _this.props[type === 'touchend' ? 'onDragEnd' : 'onDragCancel']();\n        }\n      });\n\n      _this.tracingTouchId = null;\n\n      _this.autoplayIfEnabled();\n    };\n\n    _this.onSpringRest = function () {\n      if (!_this.shouldEnableSpring()) return;\n\n      _this.setState({\n        springing: false\n      });\n\n      var cursor = Math.round(_this.usedCursor);\n      var index = -cursor;\n      var modIndex = index % _this.props.cardCount;\n\n      while (modIndex < 0) {\n        modIndex += _this.props.cardCount;\n      }\n\n      _this.props.onRest(index, modIndex, cursor, _this.state);\n    };\n\n    _this.autoplayIfEnabled = function () {\n      if (_this.props.autoplay) {\n        _this.autoplayTimer = setInterval(_this.next, _this.props.autoplay);\n      }\n    };\n\n    _this.stopAutoplay = function () {\n      if (_this.autoplayTimer) {\n        clearInterval(_this.autoplayTimer);\n        _this.autoplayTimer = null;\n      }\n    };\n\n    _this.go = function (n) {\n      return _this.modCursor().then(function () {\n        // n must be in range here.\n        // That's why next()/prev() don't use this method.\n        _this.setCursor(n);\n      });\n    };\n\n    _this.next = function () {\n      return _this.modCursor().then(function () {\n        _this.setCursor(_this.state.cursor - 1);\n      });\n    };\n\n    _this.prev = function () {\n      return _this.modCursor().then(function () {\n        _this.setCursor(_this.state.cursor + 1);\n      });\n    };\n\n    _this.setCursor = function (cursor) {\n      var springing = _this.shouldEnableSpring() && cursor !== _this.state.cursor;\n\n      return new Promise(function (resolve) {\n        _this.setState({\n          cursor: cursor,\n          springing: springing\n        }, resolve);\n      });\n    };\n\n    _this.modAs = function (cursor) {\n      return new Promise(function (resolve) {\n        _this.setState({\n          moding: true,\n          cursor: cursor\n        }, function () {\n          _this.setState({\n            moding: false\n          }, resolve);\n        });\n      });\n    };\n\n    _this.modCursor = function () {\n      return new Promise(function (resolve) {\n        var _this$props5 = _this.props,\n            loop = _this$props5.loop,\n            cardCount = _this$props5.cardCount;\n\n        if (!loop) {\n          return resolve();\n        }\n\n        var cursor = _this.state.cursor;\n        var newCursor = (0, _utils.modCursor)(cursor, cardCount);\n\n        if (newCursor !== cursor) {\n          _this.modAs(newCursor).then(resolve);\n        } else {\n          resolve();\n        }\n      });\n    };\n\n    _this.shouldEnableSpring = function () {\n      var _this$state = _this.state,\n          active = _this$state.active,\n          moding = _this$state.moding;\n      return !active && !moding;\n    };\n\n    _this.state = {\n      cursor: props.defaultCursor,\n      active: false,\n      dragging: false,\n      springing: false,\n      moding: false\n    };\n    _this.usedCursor = 0;\n    _this.touchCount = 0;\n    _this.touchMoves = [];\n    _this.autoplayTimer = null;\n    _this.grabbing = false;\n    _this.tracingTouchId = null;\n    _this.isMovingCross = null;\n    return _this;\n  }\n\n  _createClass(TouchCarousel, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.autoplayIfEnabled();\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.autoplay !== this.props.autoplay) {\n        this.stopAutoplay();\n        this.autoplayIfEnabled();\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.stopAutoplay();\n    }\n  }, {\n    key: 'getCursor',\n    value: function getCursor() {\n      return this.state.cursor;\n    }\n  }, {\n    key: 'getComputedCursor',\n    value: function getComputedCursor() {\n      var _props = this.props,\n          cardCount = _props.cardCount,\n          loop = _props.loop,\n          maxOverflow = _props.maxOverflow;\n      var _state = this.state,\n          cursor = _state.cursor,\n          dragging = _state.dragging;\n      var computedCursor = cursor;\n\n      if (!loop) {\n        computedCursor = (0, _utils.clamp)(computedCursor, 1 - cardCount, 0);\n\n        if (dragging && cursor > 0) {\n          computedCursor = maxOverflow - maxOverflow / (cursor + 1);\n        } else if (dragging && cursor < 1 - cardCount) {\n          computedCursor = 1 - cardCount - maxOverflow + maxOverflow / (1 - cardCount - cursor + 1);\n        }\n      }\n\n      return computedCursor;\n    }\n  }, {\n    key: 'getUsedCursor',\n    value: function getUsedCursor() {\n      return this.usedCursor;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props2 = this.props,\n          Component = _props2.component,\n          cardSize = _props2.cardSize,\n          cardCount = _props2.cardCount,\n          cardPadCount = _props2.cardPadCount,\n          renderCard = _props2.renderCard,\n          tension = _props2.tension,\n          friction = _props2.friction,\n          precision = _props2.precision,\n          loop = _props2.loop,\n          rest = _objectWithoutProperties(_props2, ['component', 'cardSize', 'cardCount', 'cardPadCount', 'renderCard', 'tension', 'friction', 'precision', 'loop']);\n\n      var padCount = loop ? cardPadCount : 0;\n      var springConfig = {\n        tension: tension,\n        friction: friction,\n        precision: precision\n      };\n      var computedCursor = this.getComputedCursor();\n      return _react2.default.createElement(_reactSpring.Spring, {\n        config: springConfig,\n        from: {\n          cursor: computedCursor\n        },\n        immediate: !this.shouldEnableSpring(),\n        to: {\n          cursor: computedCursor\n        },\n        onRest: this.onSpringRest\n      }, function (_ref) {\n        var cursor = _ref.cursor;\n        _this2.usedCursor = cursor;\n        return _react2.default.createElement(Component, _extends({}, (0, _utils.omit)(rest, propsKeys), {\n          cursor: cursor,\n          carouselState: _this2.state,\n          onTouchStart: _this2.onTouchStart,\n          onTouchMove: _this2.onTouchMove,\n          onTouchEnd: _this2.onTouchEndOrCancel,\n          onTouchCancel: _this2.onTouchEndOrCancel\n        }), (0, _utils.range)(0 - padCount, cardCount - 1 + padCount).map(function (index) {\n          var modIndex = index % cardCount;\n\n          while (modIndex < 0) {\n            modIndex += cardCount;\n          }\n\n          return renderCard(index, modIndex, cursor, _this2.state);\n        }));\n      });\n    }\n  }]);\n\n  return TouchCarousel;\n}(_react2.default.PureComponent);\n\nTouchCarousel.defaultProps = defaultProps;\nexports.default = TouchCarousel;","map":null,"metadata":{},"sourceType":"script"}